/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/*************************************************
* Libraries include
*************************************************/
#include "stm32l476xx.h"
#include "stdbool.h"
/*************************************************
* definition variables
*************************************************/
bool state=true;
int Read=0;
//#define COUNT 499;
/*************************************************
* function prototyping
*************************************************/

/*************************************************
* External Interrupt handler
*************************************************/
/*
void EXTI15_10_IRQHandler(void)
{
	if(EXTI->PR1 & (1 << 13)) {
		GPIOA->ODR ^= (uint16_t)(1 << 5);    //sin atirrebote

		for(uint32_t j=0; j<1000000; j++);
	}
	EXTI->PR1 = 0x2000;
}
*/
void EXTI15_10_IRQHandler(void)
{
	if(EXTI->PR1 & (1 << 13)) {
		uint16_t Read=GPIOC->IDR;  //asigna el valor de ese registro
		Read &= (1<<13);   //limpia bits excepto los que se necesitan
		if(Read== 0x2000 && state ){
				TIM2->CR1 |= (1<<0);   //Enciende timmer
				state=false;
		}

		    else{
		    	__NOP();
		   }
	   }
	EXTI->PR1=0x2000;
  }




void TIM2_IRQHandler(void){

	    // clear interrupt status
	if (TIM2->DIER & 0x01) {
	      if (TIM2->SR & 0x01) {
	           TIM2->SR &= ~(1U << 0);
	        }
	  }

	  uint16_t Read=GPIOC->IDR;
	  Read &= (1 << 13);
	  if(Read==(1 << 13)){
	  	  GPIOA->ODR ^= (uint16_t)(1 << 5); //encienda o apague led
	  	  state=true;
	  	  TIM2->CR1 &=0;   //Apaga timmer

	  }
}
/*
void TIM3_IRQHandler(void){

	//GPIOA->ODR ^= 0x0020;

	    // clear interrupt status
	  if (TIM3->DIER & 0x01) {
	      if (TIM3->SR & 0x01) {
	           TIM3->SR &= ~(1U << 0);
	        }
	  }
	  Read=GPIOC->IDR;
	  Read &= 0x4000;
	  if(Read==0x4000){
		  GPIOA->ODR &= 0x00000020;
		  TIM3->CR1 &=0;
	  }
	  else{
		  GPIOA->ODR &= 0x00000000;
		  TIM3->CR1 &=0;
	  }
}

*/













/*************************************************
* Main
*************************************************/
int main(void)
{
	RCC->AHB2ENR = 0x5;

	GPIOA->MODER &= 0xFFFFF7FF;
	GPIOC->MODER &= 0xF3FFFFFF;

    RCC->APB1ENR1 |= (1 << 0);
    	// fCK_PSC / (PSC[15:0] + 1)
    	// 4 MHz / n + 1 =  timer clock speed
    TIM2->PSC = 40000; //TIM Clock 2kHz
    	// set total count
    TIM2->ARR =1 ;
    	// Update Interrupt Enable
    TIM2->DIER |= (1 << 0);
    	   // enable TIM2 clock
    NVIC_SetPriority(TIM2_IRQn, 2); // Priority level 2
    	// enable TIM2 IRQ from NVIC
    NVIC_EnableIRQ(TIM2_IRQn);



	RCC->APB2ENR |= 0x00000001;
	SYSCFG->EXTICR[3] |= 0x20;
	EXTI->IMR1 |= 0x2000;
	EXTI->RTSR1 |= 0x2000;
	NVIC->IP[EXTI15_10_IRQn] = 0x10;
	NVIC_EnableIRQ(EXTI15_10_IRQn);

	//Configuraciones TIM



	// Enable Timer 2 module (CEN, bit0)
	//TIM2->CR1 |= (1 << 0);

	//GPIOA->ODR ^= 0x0020;

	/*





	*/

	while(1)
	{

	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}
